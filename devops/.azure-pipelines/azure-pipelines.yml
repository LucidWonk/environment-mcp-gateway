# MCP Gateway CI/CD Pipeline
# Automatically builds, tests, and deploys MCP server + DevOps tools to ubuntu-devops.lan

trigger:
  branches:
    include:
    - master
    - main
  paths:
    include:
    - EnvironmentMCPGateway/*
    - docker-compose*
    - devops/*
    exclude:
    - README.md
    - docs/*

variables:
  DEVOPS_SERVER: 'ubuntu-devops.lan'
  DEVOPS_USER: 'alex'  # Updated to match your SSH user
  CONTAINER_REGISTRY: 'your-registry'  # Update if using custom registry

stages:
- stage: BuildAndTest
  displayName: 'Build and Test MCP Server'
  jobs:
  - job: BuildJob
    displayName: 'Build MCP Gateway'
    pool: Default
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
      
    - task: NodeTool@0
      displayName: 'Setup Node.js'
      inputs:
        versionSpec: '20.x'
        
    - script: |
        cd EnvironmentMCPGateway
        npm ci
        npm run build
        npm run lint
      displayName: 'Build TypeScript MCP Server'
      
    - task: UseDotNet@2
      displayName: 'Setup .NET 9'
      inputs:
        packageType: 'sdk'
        version: '9.x'
        
    - script: |
        dotnet build LucidwonksMCPGateway.sln
        dotnet test EnvironmentMCPGateway.Tests/ --logger trx --results-directory TestResults --filter "FullyQualifiedName~Unit"
      displayName: 'Build and Test .NET Components (Unit Tests Only)'
      
    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/TestResults/*.trx'
      condition: always()
      
    - script: |
        cd EnvironmentMCPGateway
        docker build -f docker/Dockerfile -t mcp-gateway:$(Build.BuildId) .
      displayName: 'Build Docker Image'
      
    - script: |
        docker save mcp-gateway:$(Build.BuildId) | gzip > mcp-gateway-$(Build.BuildId).tar.gz
      displayName: 'Export Docker Image'
      
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Docker Image'
      inputs:
        pathtoPublish: 'mcp-gateway-$(Build.BuildId).tar.gz'
        artifactName: 'docker-image'

- stage: Deploy
  displayName: 'Deploy to ubuntu-devops.lan'
  dependsOn: BuildAndTest
  condition: succeeded()
  jobs:
  - deployment: DeployJob
    displayName: 'Deploy MCP Server and Update DevOps Tools'
    environment: 'ubuntu-devops-lan'
    pool: Default
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: docker-image
            
          - task: CopyFilesOverSSH@0
            displayName: 'Copy Docker Image to Server'
            inputs:
              sshEndpoint: 'ubuntu-devops-ssh'  # Configure this service connection
              sourceFolder: '$(Pipeline.Workspace)/docker-image'
              contents: '*.tar.gz'
              targetFolder: '/tmp/mcp-deploy'
              
          - task: CopyFilesOverSSH@0
            displayName: 'Copy Deployment Files'
            inputs:
              sshEndpoint: 'ubuntu-devops-ssh'
              sourceFolder: '$(Build.SourcesDirectory)'
              contents: |
                docker-compose.production.yml
                .env.production
              targetFolder: '/opt/mcp-gateway'
              
          - task: SSH@0
            displayName: 'Deploy MCP Server and Update Bytebase'
            continueOnError: false
            inputs:
              sshEndpoint: 'ubuntu-devops-ssh'
              runOptions: 'commands'
              failOnStderr: false
              commands: |
                # Debug: Check deployment directory exists and is accessible
                echo "Checking /opt/mcp-gateway directory:"
                ls -la /opt/mcp-gateway/ || echo "Cannot access /opt/mcp-gateway"
                
                # Load new MCP server image
                docker load < /tmp/mcp-deploy/mcp-gateway-$(Build.BuildId).tar.gz
                docker tag mcp-gateway:$(Build.BuildId) mcp-gateway:latest
                
                # Check for image updates and restart only if needed
                echo "Checking for image updates..."
                
                # Pull latest images and check if any changed
                BYTEBASE_UPDATED=false
                PORTAINER_UPDATED=false
                
                # Check Bytebase update
                BYTEBASE_OLD=$(docker images --format "{{.ID}}" bytebase/bytebase:latest 2>/dev/null || echo "none")
                docker-compose -f /opt/mcp-gateway/docker-compose.production.yml pull bytebase >/dev/null 2>&1 || true
                BYTEBASE_NEW=$(docker images --format "{{.ID}}" bytebase/bytebase:latest 2>/dev/null || echo "none")
                if [ "$BYTEBASE_OLD" != "$BYTEBASE_NEW" ]; then
                  BYTEBASE_UPDATED=true
                  echo "Bytebase image updated"
                else
                  echo "Bytebase image unchanged"
                fi
                
                # Check Portainer update
                PORTAINER_OLD=$(docker images --format "{{.ID}}" portainer/portainer-ce:latest 2>/dev/null || echo "none")
                docker-compose -f /opt/mcp-gateway/docker-compose.production.yml pull portainer >/dev/null 2>&1 || true
                PORTAINER_NEW=$(docker images --format "{{.ID}}" portainer/portainer-ce:latest 2>/dev/null || echo "none")
                if [ "$PORTAINER_OLD" != "$PORTAINER_NEW" ]; then
                  PORTAINER_UPDATED=true
                  echo "Portainer image updated"
                else
                  echo "Portainer image unchanged"
                fi
                
                # Always restart MCP Gateway (we built a new image)
                echo "Restarting MCP Gateway with new build..."
                docker-compose -f /opt/mcp-gateway/docker-compose.production.yml stop environment-mcp-gateway
                docker-compose -f /opt/mcp-gateway/docker-compose.production.yml up -d environment-mcp-gateway
                
                # Conditionally restart other services
                if [ "$BYTEBASE_UPDATED" = true ]; then
                  echo "Restarting Bytebase due to image update..."
                  docker-compose -f /opt/mcp-gateway/docker-compose.production.yml stop bytebase
                  docker-compose -f /opt/mcp-gateway/docker-compose.production.yml up -d bytebase
                fi
                
                if [ "$PORTAINER_UPDATED" = true ]; then
                  echo "Restarting Portainer due to image update..."
                  docker-compose -f /opt/mcp-gateway/docker-compose.production.yml stop portainer
                  docker-compose -f /opt/mcp-gateway/docker-compose.production.yml up -d portainer
                fi
                
                # Ensure all services are running (start any that aren't without affecting running ones)
                echo "Ensuring all services are running..."
                docker-compose -f /opt/mcp-gateway/docker-compose.production.yml up -d
                
                # Clean up unused images and containers
                docker container prune -f >/dev/null 2>&1 || true
                docker image prune -f >/dev/null 2>&1 || true
                
                # Wait for services to start
                sleep 15
                
                # Verify deployment
                echo "Checking container status:"
                docker ps
                
                # Clean up
                rm -f /tmp/mcp-deploy/mcp-gateway-$(Build.BuildId).tar.gz
                
          - task: SSH@0
            displayName: 'Health Check Services'
            inputs:
              sshEndpoint: 'ubuntu-devops-ssh'
              runOptions: 'commands'
              failOnStderr: false
              commands: |
                # Wait for services to be ready
                sleep 30
                
                # Show container status first
                echo "=== Container Status ==="
                docker ps -a
                
                echo "=== MCP Gateway Logs (last 50 lines) ==="
                docker logs --tail 50 environment-mcp-gateway || echo "No MCP Gateway logs available"
                
                echo "=== Network Status ==="
                docker network ls
                
                echo "=== Port Binding Check ==="
                netstat -tlnp | grep -E ":(3002|8080|9000)" || echo "No services bound to expected ports"
                
                # Check MCP Gateway health with more details
                echo "=== Testing MCP Gateway Health ==="
                curl -v http://localhost:3002/health || echo "MCP Gateway health check failed"
                
                # Check if container is actually running
                if docker ps | grep -q environment-mcp-gateway; then
                  echo "MCP Gateway container is running"
                else
                  echo "ERROR: MCP Gateway container is not running"
                  exit 1
                fi
                
                # Check Bytebase health  
                echo "=== Testing Bytebase Health ==="
                curl -f http://localhost:8080/api/ping || echo "Bytebase health check failed"
                
                # Check Portainer health
                echo "=== Testing Portainer Health ==="
                curl -f http://localhost:9000/api/system/status || echo "Portainer health check failed"
                
                echo "=== Health Check Summary Complete ==="